import os
import pickle
import secrets
import asyncio
from flask import Flask, flash, Response, request, redirect, url_for, render_template
from flask_login import UserMixin, LoginManager, login_required, logout_user, login_user
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from asgiref.wsgi import WsgiToAsgi
from hypercorn.config import Config
from hypercorn.asyncio import serve
from smallFunctions import delete_files, allowed_file, return_model, generate_name, generate_samples
from formsClasses import LoginForm

# global variables
MODELS = [pickle.load(open('gmm.pickle', "rb")), pickle.load(open('ctgan.pickle', "rb"))]
ALLOWED_MODELS = [type(m) for m in MODELS]
ALLOWED_EXTENSIONS = {'pickle'}
UPLOAD_FOLDER = "uploads"

# init Flask app
app = Flask(__name__)
app.debug = True
app.config['SECRET_KEY'] = secrets.token_hex(16)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.app_context().push()

# init SQLAlchemy
db = SQLAlchemy(app)


class Users(db.Model, UserMixin):
    """
    Class for SQLAlchemy. It's example how to save login informations
    """
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))

    def password(self, password: str):
        """
        Hash password
        :param password: password for account
        :return: hashed version of password
        """
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password: str) -> bool:
        """
        Compare if password is equal to hashed password
        :param password: password to check
        :return: True if password is correct, else return False
        """
        return check_password_hash(self.password_hash, password)


# Init Flask-login manager
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'


@login_manager.user_loader
def load_user(user_id):
    """
    login_manager helper
    """
    return Users.query.get(int(user_id))


# website app:
# main site
@app.route('/')
async def home():
    return render_template('home.html')


# site for logging in
@app.route('/login', methods=['GET', 'POST'])
async def login():
    form = LoginForm()
    if form.validate_on_submit():  # check whats inside forms
        user = Users.query.filter_by(username=form.username.data).first()
        if user:  # if users exists check passwords
            if check_password_hash(user.password_hash, form.password.data):
                login_user(user)
                return redirect(url_for('dashboard'))
            else:  # wrong password
                flash("Złe hasło")
        else:  # user doesn't exists
            flash("Błędny login i hasło")
    return render_template('login.html', form=form)


# site for logging out
@app.route('/logout', methods=['GET', 'POST'])
@login_required
async def logout():
    logout_user()
    flash("Wylogowano")
    return redirect(url_for('login'))


# site after logging in
@app.route('/dashboard')
@login_required
async def dashboard():
    return render_template('dashboard.html')


# site with example models
@app.route('/downloadExample')
async def downExample():
    return render_template('downloadSample.html')


# generate and send samples generated by default models to user
@app.route('/downcsv')
async def downcsv():
    data = request.values.to_dict(flat=False)
    csv = generate_samples(mtype=data['type'][0],
                           nsamples=int(data['number'][0]))
    return Response(
        csv,
        mimetype="text/csv",
        headers={"Content-disposition":
                     "attachment; filename=syntheticData{}{}.csv".format(data['type'][0], data['number'][0])})


# site of uploading models
@app.route('/upload', methods=['GET', 'POST'])
@login_required
async def upload():
    if request.method == 'POST':  # handle incoming to app models from users
        # check if the post request has the file part
        if 'file' not in request.files:
            flash('Nie wybrano pliku')
            return redirect(request.url)
        file = request.files['file']
        # If the user does not select a file, the browser submits an
        # empty file without a filename.
        if file.filename == '':
            flash('Nie wybrano pliku')
            return redirect(request.url)
        # check if file type is allowed
        if file and not allowed_file(filename=file.filename, allowed_extension=ALLOWED_EXTENSIONS):
            flash('Złe rozszerzenie pliku')
            return redirect(request.url)
        else:
            filename = generate_name()
            path_to_file = f'./{UPLOAD_FOLDER}/{filename}'

            # save and load model to check it
            file.save(path_to_file)
            check_model = pickle.load(open(path_to_file, "rb"))
            # check if model is supported by app
            # if not delete so app won't store it
            if type(check_model) not in ALLOWED_MODELS:
                flash('Zły model')
                os.remove(path_to_file)
                return redirect(request.url)

            return redirect(url_for('sampleModel', name=filename))
    return render_template('upload_site.html')

# return all upload files (its temporary function to check if deleting is working properly on server)
@app.route('/upload/list')
async def uploadList():
    ulist = str([f for f in os.listdir(UPLOAD_FOLDER)])
    return ulist

# site for downloading samples generated by uploaded models
@app.route('/sampleModel/<name>')
async def sampleModel(name):
    return render_template('sampleModel.html', modelName=name)


# generate and send samples generated by user's model to user
@app.route('/downModelCsv/<name>')
async def downModelCsv(name):
    data = request.values.to_dict(flat=False)
    path_to_file = f'./{UPLOAD_FOLDER}/{name}'
    # check if file exists (models are deleted after 5 minutes)
    if not os.path.isfile(path_to_file):
        flash("Model został już usunięty lub nie istnieje. Wgraj nowy model")
        return redirect(url_for('upload'))
    model = pickle.load(open(f'{path_to_file}', "rb"))

    csv = generate_samples(mtype=return_model(model=model,
                                              allowed_models=ALLOWED_MODELS),
                           nsamples=int(data['number'][0]),
                           model_name=path_to_file)

    return Response(
        csv,
        mimetype="text/csv",
        headers={"Content-disposition":
                     "attachment; filename=syntheticData{}{}.csv".format(return_model(model=model, allowed_models=ALLOWED_MODELS), data['number'][0])})


# invalid url
@app.errorhandler(404)
def page_not_found(e):
    print(e)
    return render_template("404.html"), 404


# internal server error
@app.errorhandler(500)
def page_not_found(e):
    print(e)
    return render_template("500.html"), 500


# async handler
async def main():
    asgi_app = WsgiToAsgi(app)
    await asyncio.gather(
        delete_files(folder_path=UPLOAD_FOLDER),
        serve(asgi_app, Config())
    )


if __name__ == '__main__':
    asyncio.run(main())
